# State Voter Files


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Motivation

_Who_ one votes for is private, but _when_ someone votes is a matter of public record. A state's Secretary of State (SOS) maintains a public record of who voted. The accompanying data may vary state by state. For example, the state of New Hampshire does not record the age of the person voting. Companies such as [Catalist](https://www.catalist.us/data/) have built their business around aggregating, cleaning, and enhancing public voter files. However, these databases can be quite expensive and are not updated at the same pace as the state voter file. 

## Overview

In this section we will demonstrate how to programatically download and clean the state voterfile. From there, we will identify potential voters and canvassing targets. Once those targets have been identified, they can  be uploaded as a list into VAN based on their SOS ID which should be present depending on your provider. 

The OH SOS website provide links to the [voter file](https://www6.sos.state.oh.us/ords/f?p=VOTERFTP:STWD:::#stwdVtrFiles) which are updated frequently. These files were last updated on July 19th, 2019 as of today (July 21st, 2019). We will combine the webscraping tools (`rvest`) that we previously learned and combine them with `dplyr` and `data.table`—a package that works exceptionally well with large data, see the [wiki](https://github.com/Rdatatable/data.table/wiki) for a primer.

## Exercise

As always, let's set up our workspace. 

```{r message=FALSE, warning=FALSE}
library(rvest)
library(data.table)
library(dplyr)
```

The first step is to use `rvest` to identify the URLs that we can use to download the voter-file. To do this, use the [inspector tool](https://atendesigngroup.com/blog/how-determine-which-css-styling-element) in your web browser and identify the HTML elements of interest. In this use case, we will specify the `highlight-row` class and the `a` (anchor) tag. The `a` tag is used to create hyperlinks within a document. The `href` attribute is used to specify the hyperlink. We can extract the `href` attribute using `rvest::html_attr()`. 


### Identifying download links

```{r}
session <- html_session("https://www6.sos.state.oh.us/ords/f?p=VOTERFTP:STWD:::#stwdVtrFiles")

html_nodes(session, ".highlight-row a") %>% 
  html_attr("href")
```

Notice that this does not actually provide the full URL that is needed, but rather the query parameters. We can iteratively append this to the base url—in this case `https://www6.sos.state.oh.us/ords/`—using `purrr::map()`.

```{r}
file_urls <- html_nodes(session, ".highlight-row a") %>% 
  html_attr("href") %>% 
  purrr::map_chr(~paste0("https://www6.sos.state.oh.us/ords/", .))

file_urls
```

With that, we now have the file paths for the four statewide voter file data sets. For the sake of computation and memory, we will only work with the first URL.

### Download the voter file 

Now that we have the links to the voter file, we can use R to download them using `download.file()`. The first argument is the link to the file, the second is the destination of that file. Here we are saving the first file into the data folder. You can also do this iteratively using `purrr::map()`. 


```{r, eval = FALSE}
# download the file as a .txt.gz (that's the file format if you download it from the web)
download.file(file_urls[1], destfile = "data/SWVF_1_22 (Adams-Erie).txt.gz")
```

Note that the file is in `.gz` compressed format. We can uncompress this using `R.utils::gunzip()` which will return the compressed file. 

```{r, eval = FALSE}
R.utils::gunzip("data/SWVF_1_22 (Adams-Erie).txt.gz")
```

data.table reads text files using `fread()`. Since this file is very large, we will take only the first 10,000 observations. Do this by setting the `nrows` argument to `10000`. Since data.table is an extension upon the `data.frame`, we can combine both data.table aand dplyr functions. 

### Voter file exploratoration

```{r}
swvf <- fread("data/SWVF_1_22 (Adams-Erie).txt", nrows = 10000)
```

Do your due dilligence and look at _all_ 106 columns. This is a great time to embrace dirty data. Are the data [tidy](https://vita.had.co.nz/papers/tidy-data.pdf)? 

```{r}
glimpse(swvf)
```

Nope! They are not tidy. Currently each row represents one voter and the events are on the columns following the format `ELECTION TYPE-MM/DD/YYYY`. The date of the election should be its own column as should the type (i.e. general, primary, or special). These data need to be converted to a longer format where each row is a unique combination of one voter and election. This means that if an individual voted in five elections, there would be five observations.

There are two main steps that need to be taken to tidy up these data. Collect the column headers and their respective values into two new columns: `election`, and `party`. Since the column headers contain two variables of interest, namely the election type and election date, the column will be split into two.

Usually we would use `gather()` or `pivot_longer()` from `tidyr`. However, these data are quite large and we need to write preformative code. data.table uses `data.table::melt()` to preform the same operation but is much faster. In this example we specify the `id` columns. These are the columns that will not be gathered into a new column. We also specify the name of the variable that will be created from the column headers with the `variable.name` argument. Next, we specfiy the name of the column that will contain the values.

```{r message=FALSE, warning=FALSE}
sw_gathered <- swvf %>% 
  melt(id = 1:46, variable.name = "election", value.name = "party") %>% 
  janitor::clean_names()
```

Preview the results of `melt()`. The example below uses `dplyr::distinct()` to identify unique value pairs. 

```{r}
# Now we can view the results. The election column can be easily split into two different columns. The election type (i.e. primary or general) and the date of the election. Next, the result column looks like there is a lot of room for cleaning. There are "" where NA should be. 
distinct(sw_gathered, election, party)
```

Notice that there are multiple values for `party`. What are these?

```{r}
# what are the unique values?
distinct(sw_gathered, party)
```

### Tidying

The SOS website has a downloadable data dictionary. The _Voter File Layout_ says:

> The data dictionary Variable filed name with election type and date of each election. Value for this field indicates how the voter voted in that election. 


| Abbr. | Party Name |
| ----- | ---------- |
| C | Constitution Party |
| D | Democrat Party |
| E | Reform Party  |
| G | Green Party |
| L | Libertarian Party |
| N | Natural Law Party |
| R | Republican Party |
| S | Socialist Party  |
| X | Voted without declaring party affiliation |
| Blank | Indicates that there is no voting record for this voter for this election |

We can use this to clean up the party field using `case_when()`. To create two separate columns for the election type and date, we can split on the first `-`. `tidyr::separate()` will split the column into two or more columns based on the `sep` argument. Once the `election_date` column has been created, we will need to parse it accordingly using lubridate. Since the date column is formatted as `MM/DD/YYYY` we can use `lubridate::mdy()` to parse it to class `Date`.

```{r}
sw_clean <- sw_gathered %>% 
  tidyr::separate(election, into = c("election_type", "election_date"), sep = "-") %>% 
  mutate(election_date = lubridate::mdy(election_date),
         party = case_when(
           party == "C" ~ "Constitution",
           party == "D" ~ "Democrat",
           party == "E" ~ "Reform",
           party == "G" ~ "Green",
           party == "L" ~ "Libertarian",
           party == "N" ~ "Natural Law",
           party == "R" ~ "Republican",
           party == "S" ~ "Socialist",
           party == "X" ~ "Independent"
         ))

head(sw_clean)
```


### Creating targets

One thing that you will need to do is identify your potential voter base. These voters are sometimes referred to as your "targets" or your voter "universe". Each voter is a unique culmination of experience, opinions, and biases. As such, not every person will be willing to vote for your candidate or maybe to even vote at all. Some people are habitual voters who vote in every election and always along party lines. Others may only sometimes vote in a general election. And others might not vote consistently along party lines. 

Due to the never ending complexities that are peoples' preferences and persuasions it is important to break the pool of potential voters down into smaller groups which I will refer to as _tiers_. We will break our voters into three distinct tiers. These categorizations are rather crude. Work with your state leadership team to determine the best way to segment your voter base.

Tier 1. Base voters - registered Democrats who have voted Democrat in a primary
Tier 2. Motivation - are not registered with a party but have voted Democrat in a primary
Tier 3. Persuasion - folks that have voted Democrat in a priimary but aren't registered as such


To begin this process, we want to identify everyone who has voted Democrat in a primary. We will filter `sw_clean` to these criteria. Then we will count the number of times each voter has voted for a Democrat. This will then be joined back to the original data frame so we can identify those people who have voted Democrat even if it conflicts with their party registration.

```{r}
# One thing that you will need to do is to identify your target base voters. These will most likely be those who have voted Democrat in previous primaries. Then we will compare those people with their registered party. 
primary_dems <- sw_clean %>% 
  filter(election_type == "PRIMARY",
         party == "Democrat") %>% 
  count(sos_voterid, party)

head(primary_dems)
```

Now that we have a table of everyone who has voted for a Democrat in a primary, we need to join this back onto the original voter file. The motivation for this is that by joining back onto the orginal table we can then use some of the other information that it provides such as party affiliation and birth year, among others.


```{r}
# join these back to the original voter file to get additional information 
potential_targets <- inner_join(primary_dems, swvf, 
                                by = c("sos_voterid" = "SOS_VOTERID")) %>% 
  janitor::clean_names() %>% 
  select(sos_voterid, party_affiliation, precinct_name,
         date_of_birth, registration_date, party, n) %>% 
  mutate(age = as.integer((Sys.Date() - lubridate::ymd(date_of_birth)) / 365))

select(potential_targets, sos_voterid, precinct_name, party_affiliation, age, n) %>% 
  arrange(-n) %>% 
  head()
```

Let's create some cross tables to identify how many times people of each party voted for a Demorat in a primary.

```{r}
# generate some cross-tabs. Everyone loves cross tabs.
count(potential_targets, party_affiliation, party) %>% 
  mutate(prop = round(n / sum(n), 2))
```

What is most telling from this table is that 30% of individuals who voted for a Democrat in the primary have no party affiliation. Now that we have a data frame with voter IDs and their registered party. We can begin segmenting this group based on the afore mentioned definitions. This will be done with a basic `case_when()` statement.

```{r}
# Tier 1 base dems will be those that are registered dem and have voted dem
# we  will tier our targets

# Tier 2 will be our motivation group. 
# Those that aren't registered with a party, but have voted Dem


# Tier 3 will be our persuasion group. 
# These are the folks that have voted Dem but aren't registered as such. 

# export thiws and upload to VAN or other management software. 
targets <- potential_targets %>% 
  mutate(tier = case_when(
    party_affiliation == "D" ~ 1,
    party_affiliation == "" ~ 2,
    !party_affiliation %in% c("", "D") ~ 3
  ))
```

Now select voter ID and tier, write as a csv, and bulk upload into VAN!

```{r echo=FALSE}
targets %>% 
  group_by(tier) %>% 
  summarise(med_age = median(age),
            n_primaries = sum(n),
            tier_size = n()) %>% 
  mutate(p = n_primaries / sum(n_primaries))
```

